#include <stdio.h>
#include <string.h>
#include <ctype.h>
#define MAX_PROD 20
#define MAX_RHS 10
#define MAX_SYMBOL_LEN 10
#define MAX_FIRST 50
char nonTerminals[MAX_PROD][MAX_SYMBOL_LEN];
int nonTerminalCount = 0;
struct Production {
char lhs[MAX_SYMBOL_LEN];
char rhs[MAX_RHS][MAX_SYMBOL_LEN*5];
int rhsCount;
} productions[MAX_PROD];
int n;
int isNonTerminal(char *s) {
return isupper(s[0]);
}
void addNonTerminal(char *s) {
for (int i = 0; i < nonTerminalCount; i++) {
if (strcmp(nonTerminals[i], s) == 0) return;
}
strcpy(nonTerminals[nonTerminalCount++], s);
}
int equals(char *a, char *b) {
return strcmp(a, b) == 0;
}
int parseSymbol(char *str, int pos, char *sym) {
int i = pos, j = 0;
if (strncmp(&str[i], "id", 2) == 0) {
strcpy(sym, "id");
return 2;
}

if (str[i] == '(' || str[i] == ')') {
sym[j++] = str[i++];
sym[j] = '\0';
return 1;
}
if (isalpha(str[i])) {
sym[j++] = str[i++];
if (str[i] == '\'') {
sym[j++] = str[i++];
}
sym[j] = '\0';
return j;
}
sym[j++] = str[i++];
sym[j] = '\0';
return 1;
}
int findNonTerminalIndex(char *s) {
for (int i = 0; i < nonTerminalCount; i++) {
if (equals(nonTerminals[i], s)) return i;
}
return -1;
}
typedef struct {
char symbols[MAX_FIRST][MAX_SYMBOL_LEN];
int count;
} FirstSet;
int contains(FirstSet *set, char *sym) {
for (int i = 0; i < set->count; i++) {
if (strcmp(set->symbols[i], sym) == 0) return 1;
}
return 0;
}
void addToFirstSet(FirstSet *set, char *sym) {
if (!contains(set, sym)) {
strcpy(set->symbols[set->count++], sym);
}
}
void computeFirst(char *sym, FirstSet *result);

void computeFirstOfProduction(char *rhs, FirstSet *result) {
int pos = 0;
int canHaveEpsilon = 1;
while (pos < (int)strlen(rhs)) {
char nextSym[MAX_SYMBOL_LEN];
int len = parseSymbol(rhs, pos, nextSym);
pos += len;
FirstSet tempFirst = {.count = 0};
computeFirst(nextSym, &tempFirst);
int hasEpsilon = 0;
for (int i = 0; i < tempFirst.count; i++) {
if (strcmp(tempFirst.symbols[i], "#") == 0) hasEpsilon = 1;
else addToFirstSet(result, tempFirst.symbols[i]);
}
if (!hasEpsilon) {
canHaveEpsilon = 0;
break;
}
}
if (canHaveEpsilon) {
addToFirstSet(result, "#");
}
}
void computeFirst(char *sym, FirstSet *result) {
if (!isNonTerminal(sym)) {
addToFirstSet(result, sym);
return;
}
int idx = findNonTerminalIndex(sym);
if (idx == -1) return;
for (int i = 0; i < n; i++) {
if (equals(productions[i].lhs, sym)) {
for (int r = 0; r < productions[i].rhsCount; r++) {
computeFirstOfProduction(productions[i].rhs[r], result);
}
}
}

}
int main() {
printf("Enter number of productions: ");
scanf("%d", &n);
getchar();
for (int i = 0; i < n; i++) {
char line[200];
printf("Production %d: ", i + 1);
fgets(line, sizeof(line), stdin);
line[strcspn(line, "\n")] = 0;
char *arrow = strstr(line, "->");
if (!arrow) {
printf("Invalid production format.\n");
return 1;
}
int lhsLen = arrow - line;
char lhs[MAX_SYMBOL_LEN];
int idx = 0;
for (int k = 0; k < lhsLen; k++) {
if (line[k] != ' ') lhs[idx++] = line[k];
}
lhs[idx] = '\0';
addNonTerminal(lhs);
strcpy(productions[i].lhs, lhs);
char rhsPart[200];
strcpy(rhsPart, arrow + 2);
productions[i].rhsCount = 0;
char *token = strtok(rhsPart, "|");
while (token != NULL) {
char cleaned[200];
int ci = 0;
for (int c = 0; token[c]; c++) {
if (token[c] != ' ') cleaned[ci++] = token[c];
}
cleaned[ci] = '\0';
strcpy(productions[i].rhs[productions[i].rhsCount++], cleaned);

token = strtok(NULL, "|");
}
}
printf("\nFIRST Sets:\n");
for (int i = 0; i < nonTerminalCount; i++) {
FirstSet first = {.count = 0};
computeFirst(nonTerminals[i], &first);
printf("FIRST(%s) = { ", nonTerminals[i]);
for (int j = 0; j < first.count; j++) {
printf("%s", first.symbols[j]);
if (j != first.count - 1) printf(" , ");
}
printf(" }\n");
}
return 0;
}
